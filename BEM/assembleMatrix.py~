from integrate import integrate_on_0_1, SingNone, SingDiag, SingRightbottom, SingLeftupper, SingLogDiag, SingLogLeftupper, SingLogRightbottom
from numpy import matrix, zeros, array
from timekernel import *
from basis import Constant1D, Multiscale1D, Wavelet1D, Sparse_multiscale


def assembleSingleLayer(basis, space_proj, time_proj, **kwargs):
   Nx = basis.nx
   Nt = basis.nt

   if isinstance(basis, Sparse_multiscale):
      A = zeros([Nt,Nt])
      print "Nt", Nt
      for i in xrange(Nt):   #Nt=Nx=N
         for j in xrange(Nt):
            A[i,j] = BilinearformA(basis, i,j,space_proj, time_proj, m=i,n=j)
      return A

   if isinstance( basis.baseT, Constant1D):
       A = zeros([Nx*Nt,Nx])
   else:
       A = matrix(zeros((Nt*Nx,Nt*Nx)))  

   #run over the indices of all the basis functions   
   for m in xrange(Nt):
       for alpha in xrange(basis.nx):
           for beta in xrange(alpha, basis.nx): 

               if "cutoff" in kwargs and kwargs['cutoff'](basis, alpha, beta, space_proj):
                   continue # don't calculate this entry

               if isinstance( basis.baseT, Constant1D): 
                   A[m*Nx+alpha, beta]  = BilinearformA(basis, alpha,beta, space_proj,time_proj, l=m)
                   A[m*Nx+beta , alpha] = A[m*Nx+alpha,beta]

               else:
                   for n in xrange(Nt):
                       A[m*Nx+alpha, n*Nx+beta] = BilinearformA(basis, alpha,beta, space_proj,time_proj, m=m, n=n)
                       A[m*Nx+beta, n*Nx+alpha] = A[m*Nx+alpha, n*Nx+beta]
   return A

def BilinearformA(basis, alpha,beta, space_proj,time_proj,**kwargs):
    numx = 6
    if isinstance(basis.baseT, Multiscale1D):
       numx = 26
    endT = float(time_proj.length)
    basis1 = basis.baseX[alpha]
    intervals1 = basis.baseX[alpha].support
    basis2 = basis.baseX[beta]
    intervals2 = basis.baseX[beta].support

    #function to calculate the matrix entries
    from memoize import memoize
    def matrixEntries(s):
            a1,a2,b1,b2 = s
            fk2 = lambda x,y:  ( space_proj.derivative(a1+(a2-a1)*x) * space_proj.derivative(b1+(b2-b1)*y) )*(a2-a1)*(b2-b1)
            # Pick integrations routine(s)
            f =  lambda x,y: fk2(x,y)*timeQuad(-space_proj(a1+(a2-a1)*x) + space_proj(b1+(b2-b1)*y), endT, basis, **kwargs).reshape(-1,1)
            def split_and_integrate(sing, smooth, flag):
                f1 = lambda x,y: fk2(x,y) * gmmsing(-space_proj(a1+(a2-a1)*x) + space_proj(b1+(b2-b1)*y),x,y,endT, basis, **kwargs).reshape(-1,1)
                f2 = lambda x,y: fk2(x,y) * gmmsmooth(-space_proj(a1+(a2-a1)*x)+space_proj(b1+(b2-b1)*y),x,y,endT, basis, flag=flag, **kwargs)

                return integrate_on_0_1(f1, sing) + integrate_on_0_1(f2, smooth)
            if a2 < b1 or b2 < a1:
                return integrate_on_0_1(f, SingNone(numx))
            if a1 == b1:
                #return integrate_on_0_1(f, SingDiag(numx,numx))
                return split_and_integrate(SingLogDiag(numx), SingNone(numx), diag)
            elif a1 == b2:  #enforce periodicity
                #return integrate_on_0_1(f, SingLeftupper(numx,numx))
                return split_and_integrate(SingLogLeftupper(numx), SingNone(numx), lu)
            else: # Last case is a2 == b1:
                #return  integrate_on_0_1(f, SingRightbottom(numx,numx))
                return split_and_integrate(SingLogRightbottom(numx), SingNone(numx), rb)
    if isinstance(basis.baseX, Wavelet1D):
       matrixEntries = memoize(matrixEntries)
    a = 0
    for i1 in intervals1:
        for i2 in intervals2:
              # Overlapping intervals need to be split in order to be able to integrate over them.
              splittedI1 = i1.splitAt(i2.endpoints())
              splittedI2 = i2.splitAt(i1.endpoints())
              for s1 in splittedI1:
                  for s2 in splittedI2:
                     a1 = s1(0); a2 = s1(1)
                     b1 = s2(0); b2 = s2(1)
                     #todo: only works for p.w. constant basis functions
                     x = array([a1]); y = array([b1])
                     fk1 = basis1(a1+(a2-a1)*x)*basis2(b1+(b2-b1)*y)
                     a += fk1*matrixEntries( (a1,a2,b1,b2) )
    return a



def plotMatrix(A):
   from matplotlib.pyplot import figure, colorbar
   from numpy import log,abs
   f = figure()
   g = f.gca().imshow(log(abs(A)), interpolation='nearest')
   f.colorbar(g)
   f.show()
