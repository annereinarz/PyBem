from projection import circle, interval, ellipse, wibblywobbly, outside_ellipse
from basis import Const_basis, Wavelet_basis
from assembleMatrix import assembleSingleLayer
from assembleVector import assembleVector
from calcSol import calcSolIndirect, fundamentalSol
from plotHeatMap import plotSpace, plotTime, plotRadial, plotLinfty, plotConv, plotLinftySpace
from L2proj import boundaryFlux
from integrate import integrate
from exSol import  exSolt2, exSolcos, exSolcost2, exSolfun

from matplotlib.pyplot import figure, imshow, plot, loglog, title, xlabel, ylabel
from numpy import hstack, apply_along_axis, cos, array, pi, arctan2, zeros, ones, arange
from numpy.linalg import solve

import os


def dot(a,b):
    assert len(a) == len(b)
    sum = 0
    for i in range(len(a)):
        sum += a[i]*b[i]
    return sum 


result_directory = "results/indirect"
if not os.path.exists(result_directory):
    os.makedirs(result_directory)


#Chose the domain
endT = 4.
time_proj = interval(0,endT)
radius = 1.
space_proj = circle(radius)
#a = 0.8
#b = 0.2
#space_proj = ellipse(a,b)
#space_proj = outside_ellipse(a,b)
#space_proj = wibblywobbly()

#Chose g(x,t)
def g(x,t):
    h = arctan2(x[:,1],x[:,0])
    return cos(h).reshape(-1,1)
g.name = "cos"
#g = lambda x,t: t**2
#g.name = "t-squared"
#g = lambda x,t: fundamentalSol(x,t)
#g.name = "fundamental-sol"

N = 3

cnt  = 0
norm = zeros(N)
ndof = zeros(N)
max  = zeros(N)
#Chose number of degrees of freedom in time and space
for i in range(N):
    j  = i+3
    j0 = 3
    #Nx = 2**(i+1)
    #Nx2 = 2**(i+1)
    Nt = j#2**(2*j)#Nx2**2
    #print Nt, Nx
    #Chose a basis in time and space
    basis = Wavelet_basis(Nt, j, j0)
    #basis = Const_basis(Nt,2**j)
    Nx = Nx2 = basis.nx
    
    print Nx

    #Set up Matrix and vector of the right hand side
    from cutoff import cutoff
    A = assembleSingleLayer(basis, space_proj, time_proj, cutoff=partial(cutoff, a=2.5, delta=1.5))
    from assembleMatrix import plotMatrix
    plotMatrix(A)
    
    #print A
    #assert false
    print "matrix set up"
    B = assembleVector(g, basis, space_proj, time_proj)
    print "vector set up"
    
    #solve the linear system
    sol = solve(A,B).reshape(-1)
    print "linear system solved"
    #print sol
    
    #convergence values)
    norm[cnt] = dot(B,sol)
    ndof[cnt] = Nx2*Nt

    bflux = boundaryFlux(sol, basis, space_proj, time_proj)
    u = calcSolIndirect(space_proj, time_proj, bflux)
    #max[cnt] = plotLinfty(u, exSolcos, time_proj)
    #max[cnt] = plotLinftySpace(u, exSolcos, space_proj)
        
    print cnt
    cnt += 1


    fname = result_directory + "/{} {} {} i={}".format(g.name, space_proj, time_proj, i)
    with open(fname,"w") as f:
        f.write("{}\n".format(sol))


fname = result_directory + "/{} {} {} N={}".format(g.name, space_proj, time_proj, N)
with open(fname,"w") as f:
    f.write("{}\n".format(norm))
    f.write("{}\n".format(ndof))
    
plotConv([norm],ndof,['circle wavelets'])
bflux = boundaryFlux(sol, basis, space_proj, time_proj)
u = calcSolIndirect(space_proj, time_proj, bflux)
#print "Solution", u(array([0.,0.89]),t
#t = 1
#plotSpace(lambda x: u(x,t), 30)
#t = 2
#plotSpace(lambda x: u(x,t), 30)
#t = 3
#plotSpace(lambda x: u(x,t), 30)
#t = 4
#plotSpace(lambda x: u(x,t), 30)
#plotTime(u, exSolcos, endT)
plotRadial(u,exSolcos,1)
#f = figure()
#f.gca().loglog(ndof, max, 'x-')
#f.gca().set_title('convergence of the L infinity norm, indirect method')
#f.gca().set_xlabel('ndof')
#f.gca().set_ylabel('error')
#f.show()
