from projection import *
from basis import Const_multiscale, Sparse_multiscale, SparseIndices
from assembleMatrix import assembleSingleLayer
from assembleVector import assembleVector
from calcSol import calcSolIndirect, fundamentalSol
from plotHeatMap import plotSpace, plotTime, plotRadial, plotLinfty, plotConv, plotLinftySpace
from L2proj import boundaryFlux
from exSol import  exSolt2, exSolcos, exSolcost2, exSolfun
from util import dot
from solve import solveMem
from numpy.linalg import solve
from numpy import cos, array, arctan2, zeros
import os
result_directory = "results/indirect"
if not os.path.exists(result_directory):
    os.makedirs(result_directory)


#Chose the domain
endT = 4.
time_proj = interval(0,endT)
radius = 1.
space_proj = circle(radius)
#a = 0.4
#b = 0.2
#space_proj = ellipse(a,b)
#space_proj = outside_ellipse(a,b)
#space_proj = wibblywobbly()

#Chose g(x,t)
def g(x,t):
    h = arctan2(x[:,1],x[:,0])
    return t**2*cos(h).reshape(-1,1)
g.name = "cos-t2"
#g = lambda x,t: t**2
#g.name = "t-squared"
#g = lambda x,t: fundamentalSol(x,t)
#g.name = "fundamental-sol"

N = 6

cnt  = 0
norm = zeros(N)
norm2= zeros(N)
ndof = zeros(N)
max  = zeros(N)

def SIndices(level,l):
    I = []
    #find (it,ix) such that it+ix=level+1-l
    for it in range(level):
        for ix in range(level):
            if it+ix == level+1-l:
               I.append([it,ix])
    print I
    return I

#extremely inefficient
def findIndices(basis, it,ix):
    I = []
    for m in range(2**it):
        for alpha in range(2**ix):
            #find corresponding i and add to list
            for i in range(basis.nx):
               if basis.baseX[i].alpha == alpha and basis.baseT[i].m == m:
                    I.append(i)
                    break
    assert len(I) == 2**it*2**ix
    return I

#Chose number of degrees of freedom in time and space
for i in range(N):
    baseSparse = Sparse_multiscale(i+1)
    As =  assembleSingleLayer(baseSparse, space_proj, time_proj)
    Bs = assembleVector(g, baseSparse, space_proj, time_proj) 
    sols = solve(As,Bs)
    solSparse = zeros(baseSparse.nx)
    Bsparse   = zeros(baseSparse.nx)
    #Set up Matrix and vector of the right hand side
    for l in range(2):
      for (it,ix) in SIndices(i+1,l):
        basis = Const_multiscale(it,ix)
        A =  assembleSingleLayer(basis, space_proj, time_proj)
        B = assembleVector(g, basis, space_proj, time_proj)
        #u_it,ix
        sol = solve(A,B)
        I = findIndices(baseSparse,it,ix)
        solSparse[I] += (-1)**l*sol
        Bsparse[I]   += (-1)**l*B

    #convergence values)
    norm[cnt] = dot(Bsparse,solSparse)**0.5
    norm2[cnt] = dot(Bs,sols)**0.5
    print "norm is: ", norm[cnt], norm2[cnt]
    ndof[cnt] = len(solSparse)

    #bflux = boundaryFlux(sol, basis, space_proj, time_proj)
    #u = calcSolIndirect(space_proj, time_proj, bflux)
    #plotTime(u, exSolt2, endT)
    #max[cnt] = plotLinfty(u, exSolt2, time_proj)
    #max[cnt] = plotLinftySpace(u, exSolcos, space_proj)
    #plotRadial(u,exSolcos,1)
    print cnt
    cnt += 1


    #fname = result_directory + "/const {} {} {} i={}".format(g.name, space_proj, time_proj, i)
    #with open(fname,"w") as f:
    #    f.write("{}\n".format(sol))


#fname = result_directory + "/const {} {} {} N={}".format(g.name, space_proj, time_proj, N)
#with open(fname,"w") as f:
#    f.write("{}\n".format(norm))
#    f.write("{}\n".format(ndof))
    
plotConv([norm],ndof,['Gamma = circle, f = t^2'])




