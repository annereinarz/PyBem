from numpy import min,max, hstack, array
from util import norm_

#base  ---- the basis used
#alpha, beta ---- basis functions
#px    ---- projection used in space
#a,delta -- parameters of the compression, the same parameters are used here for both compressions
def cutoff(base,alpha,beta, space_proj, a,delta):
    ############################
    # FIRST MATRIX COMPRESSION #
    ############################

    #Calculate Cut-off parameter
    j  = base.baseX[alpha].j        #j for first basis function
    j1 = base.baseX[beta].j         #j for second basis function
    if j == 0 or j1 == 0:          #case of constant functions
        return False
    jmax = base.jmax
    Bjj = a*max([2**(-j),2**(-j1),2**((jmax*(2.*delta+1.)-j*(delta+4.)-j1*(delta+4.))/7.)]);

    #Calculate supports of psi_j,k and psi_j1,k1
    alpha1 = base.baseX[alpha].support[0].start
    alpha2 = base.baseX[alpha].support[-1].end
    beta1  = base.baseX[beta].support[0].start
    beta2  = base.baseX[beta].support[-1].end
    #TODO: Exceptions where the supports wrap around

    #Convert to actual element
    omega  = space_proj(array([[alpha1]]))
    omega2 = space_proj(array([[alpha2]]))

    omega1 = space_proj(array([[beta1]]))
    omega21 = space_proj(array([[beta2]]))

    #Calculate distance, only works for the circle!!!!!!
    m1 = norm_(omega - omega1)
    m2 = norm_(omega - omega21)
    m3 = norm_(omega2 - omega1)
    m4 = norm_(omega2 - omega21)

    # Ensure periodicity
    if m1 == 1.0: m1 = 0
    if m2 == 1.0: m2 = 0
    if m3 == 1.0: m3 = 0
    if m4 == 1.0: m4 = 0

    dist = min([m1,m2,m3,m4])

    #Compare
    if dist > Bjj:
        return True

    #############################
    # SECOND MATRIX COMPRESSION #
    #############################

    #Calculate Cut-off parameter
    BjjS = a*max([2.**(-j),2.**(-j1),2.**((jmax*(2.*delta+1.)-3.*max([j,j1])-(j+j1)*(delta+1.))/4.)])

    #Calculate singular support of the first basis function
    alphaEndpoints = [ s.end for s in base.baseX[alpha].support[0:-1] ]
    #Calculate singular support of the second basis function
    betaEndpoints  = [ s.end for s in base.baseX[beta ].support[0:-1] ]

    minSoFar = float('inf')
    for endpoints, omegas in [ (alphaEndpoints, (omega1,omega21)),
                                (betaEndpoints,  (omega, omega2 ))
                              ]:
       for ep in endpoints:
          for o in omegas:
             m = norm_(space_proj(array([[ep]]))-o)
             if m < minSoFar:
                minSoFar = m

    dist = minSoFar

    #Compare
    if dist > BjjS:
        return True

    return False
